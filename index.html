<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily Food & Symptom Journal</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --card: #ffffff;
      --border: #dfe3e8;
      --text: #1f2933;
      --muted: #52606d;
      --accent: #2563eb;
      --accent-2: #0ea5e9;
      --danger: #dc2626;
      --shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    h1, h2, h3, h4 {
      margin: 0 0 0.4rem;
      font-weight: 700;
    }

    h1 {
      font-size: 2rem;
      letter-spacing: -0.01em;
    }

    h2 {
      font-size: 1.2rem;
      color: var(--muted);
    }

    h3 {
      font-size: 1.05rem;
      margin-top: 1.5rem;
    }

    h4 {
      font-size: 0.95rem;
      margin-top: 0;
    }

    p {
      margin: 0.4rem 0;
      color: var(--muted);
    }

    #app {
      max-width: 1100px;
      margin: 0 auto;
      padding: 2rem 1.5rem 3rem;
    }

    .page-header {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: 1.25rem;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 1.25rem;
      margin-bottom: 1rem;
    }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      color: var(--muted);
      font-weight: 600;
      font-size: 0.95rem;
    }

    .checkbox-inline {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--muted);
      font-weight: 600;
      font-size: 0.95rem;
    }

    input[type="text"],
    input[type="time"],
    input[type="number"],
    input[type="date"],
    textarea,
    select {
      width: 100%;
      padding: 0.65rem 0.7rem;
      border: 1px solid var(--border);
      border-radius: 10px;
      font-size: 0.95rem;
      background: #fdfdfd;
      color: var(--text);
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .date-inputs {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .date-display {
      background: #fdfdfd;
      cursor: pointer;
    }

    .date-picker {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
    }

    textarea {
      min-height: 96px;
      resize: vertical;
    }

    .inline-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-end;
      margin-bottom: 0.75rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      border-radius: 10px;
      border: 1px solid transparent;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease, background-color 0.1s ease, border-color 0.1s ease;
      text-decoration: none;
      padding: 0.65rem 0.9rem;
      font-size: 0.95rem;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.12);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      border: none;
    }

    .btn-ghost {
      background: #f4f7fb;
      border-color: var(--border);
      color: var(--text);
    }

    .btn-danger {
      background: #fee2e2;
      border-color: #fecdd3;
      color: #b91c1c;
    }

    .btn-small {
      padding: 0.45rem 0.65rem;
      font-size: 0.85rem;
      border-radius: 8px;
    }

    .add-component-btn {
      margin-top: 0.6rem;
    }

    .actions-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin: 0.5rem 0 1rem;
    }

    .meal-card {
      border: 1px solid var(--border);
    }

    .meal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    .meal-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
    }

    .meal-controls {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .components-container,
    .ingredients-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .meal-name-block {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .quantity-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(120px, 140px);
      gap: 0.5rem;
      align-items: center;
    }

    .component-card {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 0.85rem;
      background: #fafbfe;
    }

    .component-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .ingredient-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 1fr)) auto;
      gap: 0.5rem;
      align-items: start;
    }

    .ingredient-row .toggle-details-btn {
      grid-column: 1 / -1;
      justify-self: flex-start;
    }

    .ingredient-details {
      display: none;
      grid-column: 1 / -1;
      padding: 0.35rem;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: #fbfdff;
      gap: 0.5rem;
      flex-direction: column;
    }

    .ingredient-row.details-open .ingredient-details {
      display: flex;
    }

    .ingredient-row .subingredients textarea {
      width: 100%;
      min-height: 72px;
    }

    .ingredient-allergens,
    .component-allergens {
      min-height: 96px;
    }

    .symptom-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem;
      width: 100%;
    }

    .symptom-field {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 0.65rem 0.75rem;
      background: #fbfdff;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      min-width: 0;
    }

    .range-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 0.5rem;
      align-items: center;
    }

    input[type="range"] {
      accent-color: var(--accent);
    }

    .range-value {
      min-width: 32px;
      text-align: right;
      font-weight: 700;
      color: var(--text);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }

    th, td {
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 0.35rem;
      text-align: left;
      font-size: 0.95rem;
    }

    th {
      color: var(--muted);
      font-weight: 700;
    }

    td:last-child {
      width: 48px;
      text-align: right;
    }

    .small-input {
      max-width: 160px;
    }

    .subingredients {
      grid-column: 1 / -1;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .muted-text {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .hidden {
      display: none !important;
    }

    .premeal-locked {
      opacity: 0.6;
      pointer-events: none;
    }

    .baseline-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 0.75rem;
    }

    .data-file-bar {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-top: 0.5rem;
    }

    .data-file-bar .actions-bar {
      margin: 0;
    }

    .data-file-status {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .meal-locked .ingredients-section {
      opacity: 0.65;
    }

    .meal-locked .ingredients-section input,
    .meal-locked .ingredients-section textarea,
    .meal-locked .ingredients-section select,
    .meal-locked .ingredients-section button,
    .meal-locked .ingredients-section .toggle-details-btn,
    .meal-locked .ingredients-section .toggle-component-btn {
      pointer-events: none;
    }

    @media (max-width: 600px) {
      .ingredient-row {
        grid-template-columns: 1fr;
      }

      td:last-child {
        width: auto;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="card" style="margin-bottom: 1.25rem;">
      <div class="section-title" style="align-items: flex-end;">
        <div>
          <h3 style="margin-bottom: 0.15rem;">Entry selector</h3>
          <p class="muted-text" style="margin: 0;">Pick an existing day or start a fresh entry for today.</p>
        </div>
        <div class="actions-bar" style="margin: 0;">
          <select id="entry-select" class="small-input" style="min-width: 220px;"></select>
          <button id="new-entry-btn" type="button" class="btn btn-primary">New entry for today</button>
          <button id="connect-data-file-btn" type="button" class="btn btn-ghost">Connect data file</button>
          <button id="create-data-file-btn" type="button" class="btn btn-primary hidden">Create companion file</button>
          <button id="import-data-file-btn" type="button" class="btn btn-ghost hidden">Import companion file</button>
          <input id="import-data-file-input" class="hidden" type="file" accept="application/json" />
        </div>
        <div class="data-file-bar">
          <div id="data-file-status" class="data-file-status">No companion data file found.</div>
        </div>
      </div>
    </div>

    <div class="page-header">
      <h1>Daily Food &amp; Symptom Journal</h1>
      <h2>Track meals, ingredients, and how you feel afterward.</h2>
    </div>

    <div class="card premeal-card">
      <label>
        Date
        <div class="date-inputs">
          <input id="date-display" class="date-display" type="text" placeholder="DD MMM YYYY" autocomplete="off" readonly />
          <input id="date-picker" class="date-picker" type="date" />
        </div>
      </label>
    </div>

    <div class="card">
      <div class="section-title">
        <h3>Pre-meal baseline</h3>
        <p class="muted-text" style="margin: 0;">Rate how you feel before eating (0 = none, 10 = worst).</p>
      </div>
      <div class="grid-two" style="margin-bottom: 0.75rem;">
        <label>
          Baseline time
          <div class="inline-row" style="gap: 0.5rem; align-items: center; margin: 0; flex-wrap: nowrap;">
            <input id="baseline-time" type="time" />
            <label class="checkbox-inline" style="margin: 0;">
              <input type="checkbox" id="baseline-approx" />
              Approximate
            </label>
          </div>
        </label>
      </div>
      <div id="baseline-symptom-grid" class="symptom-grid"></div>
      <div class="baseline-actions">
        <button type="button" class="btn btn-ghost btn-small finish-baseline-btn">✓ Finish Baseline</button>
      </div>
    </div>

    <div class="section-title">
      <h3>Meals</h3>
      <div class="actions-bar">
        <button id="add-meal-btn" type="button" class="btn btn-primary">+ Add Meal</button>
        <button type="button" class="btn btn-ghost" onclick="exportLog()">Export data</button>
      </div>
    </div>

    <div id="meals-container"></div>
    <div id="secondary-add-meal" class="actions-bar hidden" style="justify-content: flex-start;">
      <button type="button" class="btn btn-primary" id="add-meal-btn-secondary">+ Add Meal</button>
    </div>
    <div class="actions-bar" style="justify-content: flex-start;">
      <button type="button" id="save-draft-btn" class="btn btn-primary" onclick="saveDraft()">Save draft</button>
      <button type="button" class="btn btn-ghost" onclick="deleteDraft()">Delete draft</button>
    </div>
  </div>

  <!-- Templates for dynamic pieces -->
  <template id="component-template">
    <div class="component-card">
      <div class="component-header">
        <h4 class="component-title">Ingredient</h4>
        <div class="inline-row" style="margin: 0; gap: 0.5rem; align-items: center;">
          <label style="margin: 0;">Ingredient Type
            <select class="ingredient-type-select">
              <option value="single">Single Ingredient</option>
              <option value="prepared">Prepared Recipe</option>
              <option value="packaged">Packaged Food</option>
            </select>
          </label>
          <button type="button" class="btn btn-danger btn-small remove-component-btn">Remove</button>
        </div>
      </div>
      <div class="component-name-row hidden">
        <div class="grid-two">
          <label>
            Component name
            <input type="text" placeholder="e.g. Curry Sauce / Chicken / Rice" class="component-name-input" />
          </label>
          <label>
            Quantity (Optional)
            <div class="quantity-row">
              <input type="text" placeholder="e.g. 200" class="component-quantity-value" />
            <select class="component-quantity-unit">
              <option value=""></option>
              <option>g</option>
              <option>ml</option>
              <option>cup</option>
              <option>tbsp</option>
              <option>tsp</option>
              <option>pcs</option>
            </select>
          </div>
        </label>
        <label>
          Allergens (optional)
          <select class="component-allergens" multiple>
            <option>Gluten</option>
            <option>Dairy</option>
            <option>Additives</option>
            <option>Refined Sugars</option>
            <option>Caffeine</option>
            <option>None</option>
          </select>
        </label>
      </div>
    </div>
      <div class="ingredients-container"></div>
      <button type="button" class="btn btn-ghost btn-small add-ingredient-btn hidden">+ Add to Component</button>
    </div>
  </template>

  <template id="ingredient-template">
    <div class="ingredient-row">
      <input type="text" placeholder="Ingredient / Product" class="ingredient-name" />
      <div class="quantity-row">
        <input type="text" placeholder="Quantity" class="ingredient-quantity-value" />
        <select class="ingredient-quantity-unit">
          <option value=""></option>
          <option>g</option>
          <option>ml</option>
          <option>cup</option>
          <option>tbsp</option>
          <option>tsp</option>
          <option>pcs</option>
        </select>
      </div>
      <select class="ingredient-allergens" multiple>
        <option>Gluten</option>
        <option>Dairy</option>
        <option>Additives</option>
        <option>Refined Sugars</option>
        <option>Caffeine</option>
        <option>None</option>
      </select>
      <button type="button" class="btn btn-danger btn-small remove-ingredient-btn">✕</button>
      <div class="ingredient-details">
        <input type="text" placeholder="Brand / Source" class="ingredient-brand" />
        <div class="subingredients">
          <textarea placeholder="Sub-ingredients (for pre-made items), one per line (optional)"></textarea>
        </div>
      </div>
    </div>
  </template>

  <template id="timeline-row-template">
    <tr>
      <td>
        <select class="timeline-symptom"></select>
      </td>
      <td><input type="time" class="small-input timeline-time" /></td>
      <td><input type="number" min="0" class="small-input timeline-onset" readonly /></td>
      <td><button type="button" class="btn btn-danger btn-small remove-timeline-row-btn">✕</button></td>
    </tr>
  </template>

  <template id="meal-template">
    <div class="card meal-card">
      <div class="meal-header">
        <div class="meal-title">Meal</div>
        <div class="meal-controls">
          <label>
            Type
            <select class="meal-type-select">
              <option>Breakfast</option>
              <option>Lunch</option>
              <option>Dinner</option>
              <option>Snack</option>
              <option>Beverage</option>
            </select>
          </label>
          <label>
            Time eaten
            <div class="inline-row" style="gap: 0.5rem; align-items: center; margin: 0; flex-wrap: nowrap;">
              <input type="time" class="small-input meal-time-input" />
              <label class="checkbox-inline" style="margin: 0;">
                <input type="checkbox" class="meal-time-approx" />
                Approximate
              </label>
            </div>
          </label>
          <button type="button" class="btn btn-danger btn-small remove-meal-btn">✕</button>
        </div>
      </div>

      <h3>Meal Overview</h3>
      <div class="grid-two">
        <div class="meal-name-block">
          <label>
            Meal name
            <input type="text" placeholder="e.g. Chicken Curry" class="meal-name-input" />
          </label>
          <button type="button" class="btn btn-ghost btn-small show-portion-btn">+ Add Portion Size</button>
        </div>
        <div class="portion-size-row hidden">
          <label>
            Portion size (optional)
            <div class="quantity-row">
              <input type="text" placeholder="e.g. 200" class="meal-portion-value" />
              <select class="meal-portion-unit">
                <option value=""></option>
                <option>g</option>
                <option>ml</option>
                <option>cup</option>
                <option>tbsp</option>
                <option>tsp</option>
                <option>pcs</option>
              </select>
            </div>
          </label>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 0.5rem;">
        <span class="muted-text" style="font-weight: 700;">Preparation</span>
        <label class="checkbox-inline"><input type="checkbox" class="meal-note-option" value="Fresh" /> Fresh</label>
        <label class="checkbox-inline"><input type="checkbox" class="meal-note-option" value="Take-Away" /> Take-Away</label>
        <label class="checkbox-inline"><input type="checkbox" class="meal-note-option" value="Restaurant" /> Restaurant</label>
        <label class="checkbox-inline"><input type="checkbox" class="meal-note-option" value="Packaged" /> Packaged</label>
        <label class="checkbox-inline reheated-checkbox"><input type="checkbox" class="meal-note-option meal-reheated-option" value="Reheated" /> Reheated</label>
        <div class="inline-row reheated-days-row hidden" style="margin: 0; gap: 0.5rem; align-items: center;">
          <label style="margin: 0;">
            Days old
            <input type="number" min="0" class="small-input reheated-days-input" placeholder="e.g. 1" />
          </label>
        </div>
      </div>

      <div class="ingredients-section hidden">
        <h3>Ingredients</h3>
        <div class="components-container"></div>
        <button type="button" class="btn btn-ghost btn-small add-component-btn">+ Add Ingredient</button>
        <button type="button" class="btn btn-ghost btn-small finish-meal-btn">✓ Finish Logging</button>
      </div>

      <div class="symptom-section hidden">
        <div class="section-title" style="margin-bottom: 0.35rem; align-items: flex-end;">
          <h3 style="margin: 0;">Symptoms After Meal</h3>
          <div class="inline-row symptom-time-row" style="margin: 0; gap: 0.5rem; align-items: center; flex-wrap: nowrap;">
            <label style="margin: 0;">
              Symptom time
              <input type="time" class="small-input symptom-time-input" />
            </label>
            <label class="checkbox-inline symptom-approx-row" style="margin: 0;">
              <input type="checkbox" class="symptom-approx-checkbox" />
              Approximate
            </label>
          </div>
        </div>
        <div class="inline-row symptom-change-row hidden" style="margin: 0 0 0.75rem; gap: 0.75rem; align-items: center;">
          <label style="margin: 0;">Did your symptoms get worse?
            <select class="symptom-change-select">
              <option value="no">No</option>
              <option value="yes">Yes</option>
            </select>
          </label>
        </div>
        <div class="symptom-grid symptom-grid-dynamic"></div>
        <div class="grid-two macros-grid hidden" style="margin-top: 0.75rem;">
          <label>
            Fat (g)
            <input type="number" min="0" step="0.1" class="macro-input macro-fat" placeholder="e.g. 15" />
          </label>
          <label>
            Protein (g)
            <input type="number" min="0" step="0.1" class="macro-input macro-protein" placeholder="e.g. 25" />
          </label>
          <label>
            Carbohydrates (g)
            <input type="number" min="0" step="0.1" class="macro-input macro-carbs" placeholder="e.g. 40" />
          </label>
          <label>
            Fibre (g)
            <input type="number" min="0" step="0.1" class="macro-input macro-fibre" placeholder="e.g. 8" />
          </label>
        </div>
      </div>

      <div class="timeline-section hidden">
        <h3>Timeline for Meal</h3>
      <p class="muted-text">Document symptom onset to spot patterns.</p>
        <table>
          <thead>
            <tr>
              <th>Symptom</th>
              <th>Time</th>
              <th>Onset (min)</th>
              <th></th>
            </tr>
          </thead>
          <tbody class="timeline-body"></tbody>
        </table>
        <button type="button" class="btn btn-ghost btn-small add-timeline-row-btn">+ Add Symptom Event</button>
        <button type="button" class="btn btn-ghost btn-small symptom-log-btn">+ Log Symptoms</button>
      </div>
    </div>
  </template>

  <script>
    const STORAGE_KEY = 'foodJournalLog_v1';
    const DATA_FILE_NAME = 'food-journal-data.json';
    const EXPECTED_DATA_FILE_NAME = DATA_FILE_NAME;
    const HANDLE_DB_NAME = 'foodJournalHandles';
    const HANDLE_STORE_NAME = 'handles';
    const HANDLE_STORE_KEY = 'companionFile';
    const MEAL_TYPES = ['Breakfast', 'Lunch', 'Dinner', 'Snack', 'Beverage'];

    const DEFAULT_SYMPTOM_CONFIG = [
      { label: 'Tiredness / Fatigue', key: 'fatigue', scope: 'symptoms', inputType: 'slider' },
      { label: 'Diffused Redness', key: 'diffusedRedness', scope: 'symptoms', inputType: 'slider' },
      { label: 'Facial Flushing', key: 'facialFlushing', scope: 'symptoms', inputType: 'slider' },
      { label: 'Facial Bloating', key: 'facialBloating', scope: 'symptoms', inputType: 'slider' },
      { label: 'Abdominal Bloating', key: 'abdominalBloating', scope: 'digestion', inputType: 'slider' },
      { label: 'Flatulence', key: 'flatulence', scope: 'digestion', inputType: 'slider' },
      { label: 'Constipation', key: 'constipation', scope: 'digestion', inputType: 'slider' },
      { label: 'Diarrhoea', key: 'diarrhoea', scope: 'digestion', inputType: 'slider' },
      { label: 'Hand Tremors', key: 'handTremors', scope: 'symptoms', inputType: 'slider' },
      { label: 'Dizziness', key: 'dizziness', scope: 'symptoms', inputType: 'slider' },
      { label: 'Sinus Pressure', key: 'sinusPressure', scope: 'symptoms', inputType: 'slider' },
      { label: 'Headache', key: 'headache', scope: 'symptoms', inputType: 'slider' },
      { label: 'Palpitations', key: 'palpitations', scope: 'symptoms', inputType: 'slider' },
      { label: 'Itchiness', key: 'itchiness', scope: 'symptoms', inputType: 'slider' },
      { label: 'Jaw Pain', key: 'jawPain', scope: 'symptoms', inputType: 'slider' },
      { label: 'Digestive discomfort', key: 'digestiveDiscomfort', scope: 'digestion', inputType: 'slider' },
      { label: 'Steatorrhoea', key: 'steatorrhoea', scope: 'digestion', inputType: 'slider' },
      { label: 'Heart Rate Increase', key: 'heartRateIncrease', scope: 'symptoms', inputType: 'checkbox', conditionalKey: 'heartRateBpm', conditionalLabel: 'BPM', conditionalInputType: 'number' }
    ];

    let symptomConfig = [...DEFAULT_SYMPTOM_CONFIG];
    let timelineSymptomOptions = [];
    let preMealKeys = [];

    function normalizeSymptomOption(option) {
      const inputType = option.inputType || 'slider';
      return { ...option, inputType, scope: option.scope || 'symptoms' };
    }

    function applySymptomConfig(config = DEFAULT_SYMPTOM_CONFIG) {
      const usable = Array.isArray(config) && config.length ? config : DEFAULT_SYMPTOM_CONFIG;
      symptomConfig = usable.map(option => normalizeSymptomOption(option));
      preMealKeys = symptomConfig.map(cfg => cfg.key);
      timelineSymptomOptions = [...symptomConfig.map(cfg => cfg.label)];
    }

    applySymptomConfig(DEFAULT_SYMPTOM_CONFIG);

    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const monthLookup = monthNames.reduce((acc, m, idx) => {
      acc[m.toLowerCase()] = idx;
      return acc;
    }, {});

    function formatDisplayDate(dateInput) {
      let d = null;
      if (typeof dateInput === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
        const [y, m, day] = dateInput.split('-').map(n => Number(n));
        d = new Date(y, m - 1, day);
      } else {
        d = new Date(dateInput);
      }
      if (Number.isNaN(d.getTime())) return '';
      const day = String(d.getDate()).padStart(2, '0');
      return `${day} ${monthNames[d.getMonth()]} ${d.getFullYear()}`;
    }

    function todayIso() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function currentTimeHHMM() {
      const d = new Date();
      const h = String(d.getHours()).padStart(2, '0');
      const m = String(d.getMinutes()).padStart(2, '0');
      return `${h}:${m}`;
    }

    function displayToIso(displayDate) {
      const match = (displayDate || '').trim().match(/^(\d{1,2})\s+([A-Za-z]{3})\s+(\d{4})$/);
      if (!match) return null;
      const day = Number(match[1]);
      const monthIdx = monthLookup[match[2].toLowerCase()];
      const year = Number(match[3]);
      if (Number.isNaN(day) || Number.isNaN(monthIdx) || Number.isNaN(year)) return null;
      const isoMonth = String(monthIdx + 1).padStart(2, '0');
      const isoDay = String(day).padStart(2, '0');
      return `${year}-${isoMonth}-${isoDay}`;
    }

    function randomId() {
      const hasCrypto = typeof window !== 'undefined' && window.crypto && typeof window.crypto.randomUUID === 'function';
      const base = hasCrypto ? window.crypto.randomUUID() : Math.random().toString(36).slice(2);
      return `${base}-${Date.now()}`;
    }

    function normalizeEntry(entry) {
      const isoDate = entry.isoDate || displayToIso(entry.displayDate) || todayIso();
      return {
        id: entry.id || isoDate,
        isoDate,
        displayDate: entry.displayDate || formatDisplayDate(isoDate),
        notesForToday: entry.notesForToday || '',
        preMealState: { ...defaultPreMealState(), ...(entry.preMealState || {}) },
        preMealTime: entry.preMealTime || currentTimeHHMM(),
        preMealApprox: !!entry.preMealApprox,
        preMealLocked: !!entry.preMealLocked,
        preMealHeartRateIncrease: !!entry.preMealHeartRateIncrease,
        preMealHeartRateBpm: entry.preMealHeartRateBpm || '',
        meals: Array.isArray(entry.meals) ? entry.meals : [],
        createdAt: entry.createdAt || new Date().toISOString(),
        updatedAt: entry.updatedAt || new Date().toISOString()
      };
    }

    function normalizeLogObject(parsed) {
      if (!parsed || typeof parsed !== 'object') {
        return { version: 1, entries: [] };
      }
      const rawEntries = Array.isArray(parsed.entries)
        ? parsed.entries
        : Array.isArray(parsed)
          ? parsed
          : [];
      const entries = rawEntries.map(normalizeEntry);
      return {
        version: parsed.version || 1,
        entries
      };
    }

    function loadLog() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { version: 1, entries: [] };
        const parsed = JSON.parse(raw);
        return normalizeLogObject(parsed);
      } catch (e) {
        console.error('Failed to load log', e);
        return { version: 1, entries: [] };
      }
    }

    function saveLog(log) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(log));
    }

    function openHandleDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(HANDLE_DB_NAME, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(HANDLE_STORE_NAME)) {
            db.createObjectStore(HANDLE_STORE_NAME);
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function storeDataFileHandle(handle) {
      try {
        const db = await openHandleDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_STORE_NAME, 'readwrite');
          tx.objectStore(HANDLE_STORE_NAME).put(handle, HANDLE_STORE_KEY);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (err) {
        console.warn('Unable to persist data file handle', err);
      }
    }

    async function loadSavedDataFileHandle() {
      try {
        const db = await openHandleDb();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_STORE_NAME, 'readonly');
          const req = tx.objectStore(HANDLE_STORE_NAME).get(HANDLE_STORE_KEY);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      } catch (err) {
        console.warn('Unable to load saved data file handle', err);
        return null;
      }
    }

    async function clearSavedDataFileHandle() {
      try {
        const db = await openHandleDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_STORE_NAME, 'readwrite');
          tx.objectStore(HANDLE_STORE_NAME).delete(HANDLE_STORE_KEY);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (err) {
        console.warn('Unable to clear saved data file handle', err);
      }
    }

    function supportsFileAccess() {
      if (typeof window === 'undefined') return false;
      return typeof window.showOpenFilePicker === 'function' || typeof window.showSaveFilePicker === 'function' || typeof window.chooseFileSystemEntries === 'function';
    }

    async function verifyHandlePermission(handle, mode = 'readwrite') {
      if (!handle) return false;
      const opts = { mode };
      if (typeof handle.queryPermission === 'function') {
        const current = await handle.queryPermission(opts);
        if (current === 'granted') return true;
      }
      if (typeof handle.requestPermission === 'function') {
        const next = await handle.requestPermission(opts);
        return next === 'granted';
      }
      return false;
    }

    async function readLogFromFile(handle) {
      if (!handle) return { version: 1, entries: [] };
      const file = await handle.getFile();
      const text = await file.text();
      const parsed = JSON.parse(text);
      return normalizeLogObject(parsed);
    }

    async function writeLogToFile(handle, log) {
      if (!handle) return;
      const writable = await handle.createWritable();
      await writable.write(JSON.stringify(log, null, 2));
      await writable.close();
    }

    async function safeReadLogFromHandle(handle) {
      try {
        const log = await readLogFromFile(handle);
        if (!log.entries.length) {
          ensureEntryForDate(log, todayIso());
          await writeLogToFile(handle, log);
        }
        return log;
      } catch (err) {
        console.error('Reading from companion file failed, creating a fresh one.', err);
        const fallback = { version: 1, entries: [createEmptyEntry(todayIso())] };
        await writeLogToFile(handle, fallback);
        return fallback;
      }
    }

    async function promptForExistingDataFile() {
      try {
        const [handle] = await window.showOpenFilePicker({
          id: 'food-journal-open',
          types: [{ description: 'JSON file', accept: { 'application/json': ['.json'] } }],
          multiple: false
        });
        return handle;
      } catch (err) {
        if (err?.name === 'AbortError') return null;
        throw err;
      }
    }

    async function promptToCreateDataFile() {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: DATA_FILE_NAME,
          id: 'food-journal-create',
          types: [{ description: 'JSON file', accept: { 'application/json': ['.json'] } }]
        });
        const starter = { version: 1, entries: [createEmptyEntry(todayIso())] };
        await writeLogToFile(handle, starter);
        return handle;
      } catch (err) {
        if (err?.name === 'AbortError') return null;
        throw err;
      }
    }

    function defaultPreMealState() {
      return symptomConfig.reduce((acc, cfg) => {
        acc[cfg.key] = cfg.inputType === 'checkbox' ? false : 0;
        if (cfg.conditionalKey) acc[cfg.conditionalKey] = '';
        return acc;
      }, {});
    }

    function defaultSymptomState(scope = 'symptoms') {
      return symptomConfig
        .filter(cfg => (cfg.scope || 'symptoms') === scope)
        .reduce((acc, cfg) => {
          acc[cfg.key] = cfg.inputType === 'checkbox' ? false : 0;
          if (cfg.conditionalKey) acc[cfg.conditionalKey] = '';
          return acc;
        }, {});
    }

    async function loadSymptomConfig() {
      try {
        const response = await fetch('symptoms.json', { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Request failed: ${response.status}`);
        const data = await response.json();
        const options = Array.isArray(data) ? data : Array.isArray(data?.options) ? data.options : DEFAULT_SYMPTOM_CONFIG;
        applySymptomConfig(options);
      } catch (err) {
        console.warn('Falling back to default symptom list.', err);
        applySymptomConfig(DEFAULT_SYMPTOM_CONFIG);
      }
    }

    function createEmptyEntry(isoDate) {
      return {
        id: isoDate,
        isoDate,
        displayDate: formatDisplayDate(isoDate),
        notesForToday: '',
        preMealState: defaultPreMealState(),
        preMealTime: currentTimeHHMM(),
        preMealApprox: false,
        preMealLocked: false,
        preMealHeartRateIncrease: false,
        preMealHeartRateBpm: '',
        meals: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
    }

    const quantityUnits = ['g', 'ml', 'cup', 'tbsp', 'tsp', 'pcs'];
    const legacyUnits = ['pc'];

    function parseQuantity(value) {
      if (!value || typeof value !== 'string') {
        return { amount: '', unit: '' };
      }
      const trimmed = value.trim();
      if (!trimmed) return { amount: '', unit: '' };
      const compactMatch = trimmed.match(/^(.+?)(g|ml|cup|tbsp|tsp|pcs|pc)$/i);
      if (compactMatch) {
        const unit = compactMatch[2].toLowerCase() === 'pc' ? 'pcs' : compactMatch[2];
        return { amount: compactMatch[1].trim(), unit };
      }
      const parts = trimmed.split(/\s+/);
      const last = parts[parts.length - 1];
      if (quantityUnits.includes(last) || legacyUnits.includes(last)) {
        const unit = last === 'pc' ? 'pcs' : last;
        return { amount: parts.slice(0, -1).join(' '), unit };
      }
      return { amount: trimmed, unit: '' };
    }

    function setQuantityFields(valueInput, unitSelect, storedValue) {
      if (!valueInput || !unitSelect) return;
      const parsed = parseQuantity(storedValue || '');
      valueInput.value = parsed.amount;
      unitSelect.value = parsed.unit;
    }

    function collectQuantity(valueInput, unitSelect) {
      if (!valueInput || !unitSelect) return '';
      const amount = (valueInput.value || '').trim();
      const unit = (unitSelect.value || '').trim();
      if (!amount && !unit) return '';
      return unit ? `${amount} ${unit}`.trim() : amount;
    }

    function populateTimelineSymptomSelect(select, selectedValue) {
      if (!select) return;
      select.innerHTML = '';
      timelineSymptomOptions.forEach(label => {
        const opt = document.createElement('option');
        opt.value = label;
        opt.textContent = label;
        select.appendChild(opt);
      });
      if (selectedValue && timelineSymptomOptions.includes(selectedValue)) {
        select.value = selectedValue;
      } else if (timelineSymptomOptions.length) {
        select.value = timelineSymptomOptions[0];
      }
    }

    function setRangeValue(rangeEl, value = 0) {
      if (!rangeEl) return;
      const num = Number.isFinite(Number(value)) ? Number(value) : 0;
      rangeEl.value = num;
      const parent = rangeEl.parentElement;
      const display = parent ? parent.querySelector('.range-value') : null;
      if (display) display.textContent = String(num);
    }

    function buildSymptomField(cfg, mode = 'meal') {
      const field = document.createElement('div');
      field.className = 'symptom-field';
      field.dataset.inputType = cfg.inputType || 'slider';
      const label = document.createElement('label');
      label.textContent = cfg.label;
      field.appendChild(label);

      if (cfg.inputType === 'checkbox') {
        const row = document.createElement('div');
        row.className = 'inline-row';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.classList.add('symptom-checkbox');
        checkbox.dataset.group = cfg.key;
        checkbox.dataset.scope = cfg.scope || 'symptoms';
        checkbox.dataset.mode = mode;
        row.appendChild(checkbox);
        const text = document.createElement('span');
        text.textContent = cfg.label;
        text.style.fontWeight = '600';
        text.style.color = 'var(--muted)';
        row.appendChild(text);

        if (cfg.conditionalKey) {
          const conditionalLabel = document.createElement('label');
          conditionalLabel.className = 'conditional-field hidden';
          conditionalLabel.textContent = cfg.conditionalLabel || 'Detail';
          const conditionalInput = document.createElement('input');
          conditionalInput.type = cfg.conditionalInputType || 'text';
          conditionalInput.classList.add('symptom-conditional');
          conditionalInput.dataset.group = cfg.key;
          conditionalInput.dataset.conditionalKey = cfg.conditionalKey;
          conditionalInput.dataset.scope = cfg.scope || 'symptoms';
          conditionalLabel.appendChild(conditionalInput);
          row.appendChild(conditionalLabel);
        }

        field.appendChild(row);
        return field;
      }

      const row = document.createElement('div');
      row.className = 'range-row';
      const input = document.createElement('input');
      input.type = 'range';
      input.min = '0';
      input.max = '10';
      input.value = '0';
      input.classList.add('range-input');
      if (mode === 'baseline') {
        input.classList.add('premeal-range');
        input.dataset.key = cfg.key;
      } else {
        input.classList.add('symptom-range');
        input.dataset.group = cfg.key;
        input.dataset.scope = cfg.scope || 'symptoms';
      }
      const valueDisplay = document.createElement('span');
      valueDisplay.className = 'range-value';
      valueDisplay.textContent = '0';
      row.appendChild(input);
      row.appendChild(valueDisplay);
      field.appendChild(row);
      return field;
    }

    function renderBaselineSymptomGrid() {
      const grid = document.getElementById('baseline-symptom-grid');
      if (!grid) return;
      grid.innerHTML = '';
      symptomConfig.forEach(cfg => {
        const field = buildSymptomField(cfg, 'baseline');
        grid.appendChild(field);
      });
    }

    function renderMealSymptomGrid(card) {
      if (!card) return;
      const grid = card.querySelector('.symptom-grid-dynamic');
      if (!grid) return;
      grid.innerHTML = '';
      symptomConfig.forEach(cfg => {
        const field = buildSymptomField(cfg, 'meal');
        grid.appendChild(field);
      });
    }

    function collectPreMealState() {
      const state = defaultPreMealState();
      document.querySelectorAll('.premeal-range').forEach(range => {
        const key = range.dataset.key;
        if (!key) return;
        state[key] = Number(range.value) || 0;
      });
      document.querySelectorAll('.symptom-checkbox[data-mode="baseline"]').forEach(box => {
        const key = box.dataset.group;
        if (!key) return;
        state[key] = !!box.checked;
        const cfg = symptomConfig.find(c => c.key === key);
        if (cfg?.conditionalKey) {
          const conditionalInput = box.closest('.symptom-field')?.querySelector('.symptom-conditional');
          if (conditionalInput) state[cfg.conditionalKey] = conditionalInput.value || '';
        }
      });
      return state;
    }

    function populatePreMealState(state = {}) {
      const merged = { ...defaultPreMealState(), ...(state || {}) };
      document.querySelectorAll('.premeal-range').forEach(range => {
        const key = range.dataset.key;
        setRangeValue(range, merged[key]);
      });
      document.querySelectorAll('.symptom-checkbox[data-mode="baseline"]').forEach(box => {
        const key = box.dataset.group;
        box.checked = !!merged[key];
        const cfg = symptomConfig.find(c => c.key === key);
        const conditional = box.closest('.symptom-field')?.querySelector('.symptom-conditional');
        if (conditional && cfg?.conditionalKey) {
          conditional.value = merged[cfg.conditionalKey] || '';
          conditional.parentElement?.classList.toggle('hidden', !box.checked);
        }
      });
    }

    function setSymptomValues(card, symptoms = {}, digestion = {}) {
      card.querySelectorAll('.symptom-range').forEach(range => {
        const group = range.dataset.group;
        const scope = range.dataset.scope;
        const source = scope === 'digestion' ? digestion : symptoms;
        let val = source[group];
        if (group === 'handTremors' && typeof val === 'undefined') {
          val = symptoms.tremor;
        }
        setRangeValue(range, Number.isFinite(val) ? val : 0);
      });

      card.querySelectorAll('.symptom-checkbox').forEach(box => {
        const scope = box.dataset.scope;
        const group = box.dataset.group;
        const source = scope === 'digestion' ? digestion : symptoms;
        box.checked = !!source[group];
        const conditional = card.querySelector(`.symptom-conditional[data-group="${group}"]`);
        if (conditional) {
          const cfg = symptomConfig.find(c => c.key === group);
          const key = cfg?.conditionalKey;
          const value = key && scope === 'digestion' ? digestion[key] : (key ? symptoms[key] : '');
          conditional.value = value || '';
          conditional.parentElement?.classList.toggle('hidden', !box.checked);
        }
      });
    }

    function parseMealNotesValue(value) {
      if (Array.isArray(value)) return value;
      if (typeof value === 'string') {
        return value
          .split(',')
          .map(s => s.trim())
          .filter(Boolean);
      }
      return [];
    }

    function setMealNotes(card, value) {
      const selected = parseMealNotesValue(value);
      const checkboxes = card.querySelectorAll('.meal-note-option');
      checkboxes.forEach(cb => {
        cb.checked = selected.includes(cb.value);
      });
    }

    function getSelectedMealNotes(card) {
      const checkboxes = card.querySelectorAll('.meal-note-option');
      return Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    }

    function parseTimeToMinutes(value) {
      if (!value || typeof value !== 'string') return null;
      const parts = value.split(':');
      if (parts.length < 2) return null;
      const h = Number(parts[0]);
      const m = Number(parts[1]);
      if (Number.isNaN(h) || Number.isNaN(m)) return null;
      return h * 60 + m;
    }

    function updateTimelineOnsetForRow(tr) {
      if (!tr) return;
      const mealCard = tr.closest('.meal-card');
      const mealTimeInput = mealCard ? mealCard.querySelector('.meal-time-input') : null;
      const mealMinutes = mealTimeInput ? parseTimeToMinutes(mealTimeInput.value) : null;
      const timeInput = tr.querySelector('.timeline-time');
      const onsetInput = tr.querySelector('.timeline-onset');
      const eventMinutes = timeInput ? parseTimeToMinutes(timeInput.value) : null;
      if (mealMinutes === null || eventMinutes === null) {
        if (onsetInput) onsetInput.value = '';
        return;
      }
      const diff = Math.max(0, eventMinutes - mealMinutes);
      if (onsetInput) onsetInput.value = diff;
    }

    function updateAllTimelineOnsets(mealCard) {
      if (!mealCard) return;
      const rows = mealCard.querySelectorAll('.timeline-body tr');
      rows.forEach(row => updateTimelineOnsetForRow(row));
    }

    function sortMealsByTime() {
      const container = document.getElementById('meals-container');
      if (!container) return;
      const cards = Array.from(container.querySelectorAll('.meal-card'));
      const sorted = cards
        .map((card, idx) => {
          const timeInput = card.querySelector('.meal-time-input');
          const minutes = timeInput ? parseTimeToMinutes(timeInput.value) : null;
          return {
            card,
            key: minutes === null ? Number.POSITIVE_INFINITY : minutes,
            idx
          };
        })
        .sort((a, b) => (a.key - b.key) || (a.idx - b.idx));
      sorted.forEach(entry => container.appendChild(entry.card));
      renumberMeals();
    }

    function shouldShowIngredientsSection(card) {
      if (!card) return false;
      const mealName = (card.querySelector('.meal-name-input') || {}).value || '';
      const prepSelected = card.querySelectorAll('.meal-note-option:checked').length > 0;
      return !!(mealName.trim() && prepSelected);
    }

    function updateAddIngredientButtonLabel(card) {
      if (!card) return;
      const btn = card.querySelector('.add-component-btn');
      const mealNameInput = card.querySelector('.meal-name-input');
      if (!btn) return;
      const name = mealNameInput && mealNameInput.value ? mealNameInput.value.trim() : '';
      btn.textContent = name ? `+ Add Ingredient to ${name}` : '+ Add Ingredient';
    }

    function updateFinishMealButtonLabel(card) {
      if (!card) return;
      const btn = card.querySelector('.finish-meal-btn');
      if (!btn) return;
      const mealNameInput = card.querySelector('.meal-name-input');
      const name = mealNameInput && mealNameInput.value ? mealNameInput.value.trim() : 'Meal';
      btn.textContent = `✓ Finish Logging ${name}`;
    }

    function updatePortionVisibility(card) {
      if (!card) return;
      const typeSelect = card.querySelector('.meal-type-select');
      const portionToggleBtn = card.querySelector('.show-portion-btn');
      const portionRow = card.querySelector('.portion-size-row');
      if (!typeSelect || !portionToggleBtn || !portionRow) return;
      const isBeverage = typeSelect.value === 'Beverage';
      if (isBeverage) {
        portionRow.classList.add('hidden');
      }
      portionToggleBtn.classList.toggle('hidden', isBeverage || !portionRow.classList.contains('hidden'));
    }

    function shouldShowSymptomsSection(card) {
      if (!card) return false;
      const ingredientNames = card.querySelectorAll('.ingredient-name');
      for (let i = 0; i < ingredientNames.length; i++) {
        if ((ingredientNames[i].value || '').trim()) return true;
      }
      return false;
    }

    function updateIngredientsVisibility(card) {
      if (!card) return;
      const section = card.querySelector('.ingredients-section');
      if (!section) return;
      const show = shouldShowIngredientsSection(card);
      section.classList.toggle('hidden', !show);
      updateAddIngredientButtonLabel(card);
    }

    function updateTimelineVisibility(card) {
      if (!card) return;
      const section = card.querySelector('.timeline-section');
      if (!section) return;
      const rows = card.querySelectorAll('.timeline-body tr');
      const symptomRanges = card.querySelectorAll('.symptom-range');
      let hasSymptomValue = false;
      symptomRanges.forEach(range => {
        if (Number(range.value) > 0) hasSymptomValue = true;
      });
      card.querySelectorAll('.symptom-checkbox').forEach(box => {
        if (box.checked) hasSymptomValue = true;
      });
      const unlocked = card.dataset.symptomsUnlocked === '1';
      const hiddenBySelection = card.dataset.symptomFieldsHidden === '1';
      const show = unlocked && !hiddenBySelection && (hasSymptomValue || rows.length > 0);
      section.classList.toggle('hidden', !show);
    }

    function updateSymptomSectionVisibility(card) {
      if (!card) return;
      const section = card.querySelector('.symptom-section');
      if (!section) return;
      const hiddenBySelection = card.dataset.symptomFieldsHidden === '1';
      const show = (card.dataset.symptomsUnlocked === '1' || card.dataset.mealFinished === '1') && !hiddenBySelection;
      section.classList.toggle('hidden', !show);
      updateTimelineVisibility(card);
    }

    function toggleSymptomChangeRow(card, show) {
      const row = card ? card.querySelector('.symptom-change-row') : null;
      if (row) row.classList.toggle('hidden', !show);
    }

    function toggleMacroGrid(card, show) {
      const grid = card ? card.querySelector('.macros-grid') : null;
      if (grid) grid.classList.toggle('hidden', !show);
    }

    function applyBaselineSymptomsToMeal(card) {
      if (!card) return;
      const baseline = collectPreMealState();
      card.querySelectorAll('.symptom-range').forEach(range => {
        const key = range.dataset.group;
        const value = baseline[key];
        setRangeValue(range, Number.isFinite(value) ? value : 0);
      });
      card.querySelectorAll('.symptom-checkbox').forEach(box => {
        const key = box.dataset.group;
        const cfg = symptomConfig.find(c => c.key === key);
        box.checked = !!baseline[key];
        if (cfg?.conditionalKey) {
          const conditional = box.closest('.symptom-field')?.querySelector('.symptom-conditional');
          if (conditional) {
            conditional.value = baseline[cfg.conditionalKey] || '';
            conditional.parentElement?.classList.toggle('hidden', !box.checked);
          }
        }
      });
      refreshRangeDisplays();
    }

    function lockPostMealSymptoms(card, locked) {
      if (!card) return;
      const ranges = card.querySelectorAll('.symptom-range');
      ranges.forEach(range => {
        range.disabled = !!locked;
      });
      const timeInput = card.querySelector('.symptom-time-input');
      if (timeInput) timeInput.disabled = !!locked;
      const approx = card.querySelector('.symptom-approx-checkbox');
      if (approx) approx.disabled = !!locked;
      const timelineInputs = card.querySelectorAll('.timeline-section input, .timeline-section select, .timeline-section button');
      timelineInputs.forEach(el => {
        el.disabled = !!locked;
      });
      card.querySelectorAll('.symptom-checkbox, .symptom-conditional').forEach(el => {
        el.disabled = !!locked;
      });
    }

    function applySymptomChangeSelection(card, selection, { applyBaseline = false } = {}) {
      if (!card) return;
      const normalized = selection === 'yes' ? 'yes' : 'no';
      const select = card.querySelector('.symptom-change-select');
      if (select) select.value = normalized;

      const symptomSection = card.querySelector('.symptom-grid-dynamic');
      const timeRow = card.querySelector('.symptom-time-row');
      const approxRow = card.querySelector('.symptom-approx-row');

      if (normalized === 'no') {
        card.dataset.symptomFieldsHidden = '1';
        card.querySelectorAll('.symptom-range').forEach(range => {
          range.value = '';
          setRangeValue(range, 0);
        });
        card.querySelectorAll('.symptom-checkbox').forEach(box => {
          box.checked = false;
        });
        card.querySelectorAll('.symptom-conditional').forEach(input => {
          input.value = '';
          input.parentElement?.classList.add('hidden');
        });
        const timeInput = card.querySelector('.symptom-time-input');
        const approx = card.querySelector('.symptom-approx-checkbox');
        if (timeInput) timeInput.value = '';
        if (approx) approx.checked = false;
        if (symptomSection) symptomSection.classList.add('hidden');
        if (timeRow) timeRow.classList.add('hidden');
        if (approxRow) approxRow.classList.add('hidden');
      } else {
        card.dataset.symptomFieldsHidden = '0';
        if (symptomSection) symptomSection.classList.remove('hidden');
        if (timeRow) timeRow.classList.remove('hidden');
        if (approxRow) approxRow.classList.remove('hidden');
        if (applyBaseline) {
          applyBaselineSymptomsToMeal(card);
        }
      }

      lockPostMealSymptoms(card, normalized === 'no');
    }

    function collectMacros(card) {
      const getVal = selector => {
        const input = card ? card.querySelector(selector) : null;
        return input ? input.value : '';
      };
      return {
        fat: getVal('.macro-fat'),
        protein: getVal('.macro-protein'),
        carbs: getVal('.macro-carbs'),
        fibre: getVal('.macro-fibre')
      };
    }

    function setMacroFields(card, macros = {}) {
      const setVal = (selector, value) => {
        const input = card ? card.querySelector(selector) : null;
        if (input) input.value = value || '';
      };
      setVal('.macro-fat', macros.fat);
      setVal('.macro-protein', macros.protein);
      setVal('.macro-carbs', macros.carbs);
      setVal('.macro-fibre', macros.fibre);
    }

    function hasMacroValues(macros = {}) {
      return ['fat', 'protein', 'carbs', 'fibre'].some(key => macros[key]);
    }

    function setMealLockedState(card, locked) {
      if (!card) return;
      card.classList.toggle('meal-locked', !!locked);
      const ingredientFields = card.querySelectorAll('.ingredients-section input, .ingredients-section textarea, .ingredients-section select, .ingredients-section button');
      ingredientFields.forEach(el => {
        if (el.classList.contains('remove-ingredient-btn') || el.classList.contains('remove-component-btn')) {
          el.disabled = !!locked;
        } else if (el.classList.contains('toggle-component-btn') || el.classList.contains('demote-component-btn') || el.classList.contains('toggle-details-btn') || el.classList.contains('add-component-btn') || el.classList.contains('add-ingredient-btn')) {
          el.classList.toggle('hidden', !!locked);
        } else {
          el.disabled = !!locked;
        }
      });
    }

    function setMealFinishedState(card, finished) {
      if (!card) return;
      card.dataset.mealFinished = finished ? '1' : '0';
      const addBtn = card.querySelector('.add-component-btn');
      const finishBtn = card.querySelector('.finish-meal-btn');
      const typeSelect = card.querySelector('.meal-type-select');
      const mealNameInput = card.querySelector('.meal-name-input');
      const prepOptions = card.querySelectorAll('.meal-note-option');
      const removeIngredientBtns = card.querySelectorAll('.remove-ingredient-btn');
      const reheatedDaysInput = card.querySelector('.reheated-days-input');
      if (addBtn) addBtn.classList.toggle('hidden', !!finished);
      if (finishBtn) finishBtn.classList.toggle('hidden', !!finished);
      if (typeSelect) typeSelect.disabled = !!finished;
      if (mealNameInput) mealNameInput.disabled = !!finished;
      prepOptions.forEach(cb => { cb.disabled = !!finished; });
      removeIngredientBtns.forEach(btn => btn.classList.toggle('hidden', !!finished));
      if (reheatedDaysInput) reheatedDaysInput.disabled = !!finished;
      if (finished) {
        setMealLockedState(card, true);
        setSymptomsUnlocked(card, true);
        toggleSymptomChangeRow(card, true);
      }
      if (!finished) {
        toggleSymptomChangeRow(card, false);
        toggleMacroGrid(card, hasMacroValues(collectMacros(card)));
      }
      toggleMacroGrid(card, finished || hasMacroValues(collectMacros(card)));
      updateAddIngredientButtonLabel(card);
      updateFinishMealButtonLabel(card);
      updateSecondaryAddMealVisibility();
    }

    function refreshRangeDisplays() {
      document.querySelectorAll('.range-input').forEach(range => {
        setRangeValue(range, Number(range.value) || 0);
      });
    }

    function setBaselineLocked(locked) {
      const card = document.querySelector('.premeal-card');
      const btn = document.querySelector('.finish-baseline-btn');
      const isLocked = !!locked;
      if (card) card.classList.toggle('premeal-locked', isLocked);
      if (btn) {
        btn.textContent = isLocked ? '✓ Baseline Saved' : '✓ Finish Baseline';
        btn.disabled = isLocked;
      }
      document.querySelectorAll('.premeal-range').forEach(range => {
        range.disabled = isLocked;
      });
      const baselineTime = document.getElementById('baseline-time');
      const baselineApprox = document.getElementById('baseline-approx');
      if (baselineTime) baselineTime.disabled = isLocked;
      if (baselineApprox) baselineApprox.disabled = isLocked;
      const fields = document.querySelectorAll('.premeal-card .symptom-field');
      fields.forEach(field => {
        const range = field.querySelector('.range-input');
        const checkbox = field.querySelector('.symptom-checkbox');
        const hide = (range && Number(range.value) === 0) || (checkbox && !checkbox.checked);
        if (isLocked && hide) {
          field.classList.add('hidden');
        } else {
          field.classList.remove('hidden');
        }
        if (range) range.disabled = isLocked;
        if (checkbox) checkbox.disabled = isLocked;
        const conditional = field.querySelector('.symptom-conditional');
        if (conditional) conditional.disabled = isLocked;
      });
      updateBaselineDependentControls();
    }

    function setComponentMode(card, enabled) {
      const nameRow = card.querySelector('.component-name-row');
      const addBtn = card.querySelector('.add-ingredient-btn');
      const toggleBtn = card.querySelector('.toggle-component-btn');
      const demoteBtn = card.querySelector('.demote-component-btn');
      if (nameRow) nameRow.classList.toggle('hidden', !enabled);
      if (toggleBtn) toggleBtn.classList.toggle('hidden', enabled);
      if (demoteBtn) demoteBtn.classList.toggle('hidden', !enabled);
      card.dataset.componentMode = enabled ? '1' : '0';
      updateComponentTitle(card);
      updateAddToComponentButton(card);
      updateComponentToggleButton(card);
      updateDemoteButtonLabel(card);
    }

    function applyIngredientType(card, type = 'single') {
      if (!card) return;
      const select = card.querySelector('.ingredient-type-select');
      const normalized = ['prepared', 'packaged'].includes(type) ? type : 'single';
      card.dataset.ingredientType = normalized;
      if (select && select.value !== normalized) select.value = normalized;

      if (normalized === 'prepared') {
        setComponentMode(card, true);
        const nameRow = card.querySelector('.component-name-row');
        if (nameRow) nameRow.classList.remove('hidden');
        card.querySelectorAll('.ingredient-row').forEach(row => setIngredientDetailsVisibility(row, false));
      } else if (normalized === 'packaged') {
        setComponentMode(card, false);
        const nameRow = card.querySelector('.component-name-row');
        if (nameRow) nameRow.classList.add('hidden');
        const addBtn = card.querySelector('.add-ingredient-btn');
        if (addBtn) addBtn.classList.add('hidden');
        card.querySelectorAll('.ingredient-row').forEach(row => setIngredientDetailsVisibility(row, true));
      } else {
        setComponentMode(card, false);
        const nameRow = card.querySelector('.component-name-row');
        if (nameRow) nameRow.classList.add('hidden');
        const addBtn = card.querySelector('.add-ingredient-btn');
        if (addBtn) addBtn.classList.add('hidden');
        card.querySelectorAll('.ingredient-row').forEach(row => setIngredientDetailsVisibility(row, false));
      }

      updateComponentTitle(card);
      updateAddToComponentButton(card);
    }

    function promoteIngredientToComponent(card) {
      if (!card) return;
      const firstRow = card.querySelector('.ingredient-row');
      const compNameInput = card.querySelector('.component-name-input');
      const compQtyValueInput = card.querySelector('.component-quantity-value');
      const compQtyUnitSelect = card.querySelector('.component-quantity-unit');
      if (!firstRow) return;
      const ingNameInput = firstRow.querySelector('.ingredient-name');
      const ingQtyValueInput = firstRow.querySelector('.ingredient-quantity-value');
      const ingQtyUnitSelect = firstRow.querySelector('.ingredient-quantity-unit');
      const ingNameVal = ingNameInput && ingNameInput.value ? ingNameInput.value.trim() : '';
      const ingQtyVal = collectQuantity(ingQtyValueInput, ingQtyUnitSelect);
      if (compNameInput && ingNameVal) {
        compNameInput.value = ingNameVal;
        ingNameInput.value = '';
      }
      if (ingQtyVal) {
        setQuantityFields(compQtyValueInput, compQtyUnitSelect, ingQtyVal);
        if (ingQtyValueInput) ingQtyValueInput.value = '';
        if (ingQtyUnitSelect) ingQtyUnitSelect.value = '';
      }
      updateIngredientRowActions(firstRow);
      updateComponentTitle(card);
      updateAddToComponentButton(card);
      updateComponentToggleButton(card);
      updateDemoteButtonLabel(card);
    }

    function updateComponentTitle(card) {
      if (!card) return;
      const title = card.querySelector('.component-title');
      if (!title) return;
      const nameInput = card.querySelector('.component-name-input');
      const ingredientInputs = card.querySelectorAll('.ingredient-name');
      const componentMode = card.dataset.componentMode === '1';
      let label = '';
      if (nameInput && nameInput.value && nameInput.value.trim()) {
        label = nameInput.value.trim();
      } else {
        for (let i = 0; i < ingredientInputs.length; i++) {
          const val = ingredientInputs[i].value || '';
          if (val.trim()) {
            label = val.trim();
            break;
          }
        }
      }
      if (!label) {
        label = componentMode ? 'Component' : 'Ingredient';
      }
      title.textContent = label;
      updateDemoteButtonLabel(card);
    }

    function getFirstIngredientName(card) {
      const inputs = card ? card.querySelectorAll('.ingredient-name') : [];
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].value && inputs[i].value.trim()) return inputs[i].value.trim();
      }
      return '';
    }

    function updateComponentToggleButton(card) {
      if (!card) return;
      const toggleBtn = card.querySelector('.toggle-component-btn');
      if (!toggleBtn) return;
      const ingName = getFirstIngredientName(card);
      const show = card.dataset.componentMode !== '1' && !!ingName;
      toggleBtn.classList.toggle('hidden', !show);
      toggleBtn.textContent = '+ Promote to Recipe';
    }

    function updateDemoteButtonLabel(card) {
      if (!card) return;
      const demoteBtn = card.querySelector('.demote-component-btn');
      if (!demoteBtn) return;
      const ingName = card.querySelector('.component-title')?.textContent?.trim() || 'Ingredient';
      demoteBtn.textContent = `Demote ${ingName} to Ingredient`;
    }

    function updateAddToComponentButton(card) {
      if (!card) return;
      const addBtn = card.querySelector('.add-ingredient-btn');
      const nameInput = card.querySelector('.component-name-input');
      const hasName = !!(nameInput && nameInput.value && nameInput.value.trim());
      const finished = card.dataset.finished === '1';
      if (addBtn) {
        addBtn.classList.toggle('hidden', finished || !hasName || card.dataset.componentMode !== '1');
        if (hasName) {
          addBtn.textContent = `+ Add Ingredient to ${nameInput.value.trim()}`;
        } else {
          addBtn.textContent = '+ Add to Component';
        }
      }
    }

    function updateIngredientRowActions(row) {
      if (!row) return;
      const nameInput = row.querySelector('.ingredient-name');
      const nameVal = nameInput && nameInput.value ? nameInput.value.trim() : '';
      const card = row.closest('.component-card');
      updateComponentToggleButton(card);
      updateComponentTitle(card);
      applySeasoningDefaults(row);
      autoSelectAllergensFromRow(row);
    }

    function applySeasoningDefaults(row) {
      const nameInput = row ? row.querySelector('.ingredient-name') : null;
      const qtyValueInput = row ? row.querySelector('.ingredient-quantity-value') : null;
      const qtyUnitSelect = row ? row.querySelector('.ingredient-quantity-unit') : null;
      const name = (nameInput && nameInput.value ? nameInput.value : '').toLowerCase();
      if (!name || (!name.includes('salt') && !name.includes('peppercorns'))) return;
      if (qtyValueInput && !qtyValueInput.value) qtyValueInput.value = '0.25';
      if (qtyUnitSelect && !qtyUnitSelect.value) qtyUnitSelect.value = 'g';
    }

    function ensureAllergenSelected(selectEl, value) {
      if (!selectEl) return;
      Array.from(selectEl.options).forEach(opt => {
        if (opt.value === value) opt.selected = true;
      });
    }

    function autoSelectAllergensFromRow(row) {
      if (!row) return;
      const select = row.querySelector('.ingredient-allergens');
      const textarea = row.querySelector('.subingredients textarea');
      const text = (textarea && textarea.value ? textarea.value : '').toLowerCase();
      if (text.includes('sugar')) {
        ensureAllergenSelected(select, 'Refined Sugars');
      }
      if (text.includes('flavours')) {
        ensureAllergenSelected(select, 'Additives');
      }
    }

    function setIngredientDetailsVisibility(row, open) {
      if (!row) return;
      if (open) {
        row.classList.add('details-open');
      } else {
        row.classList.remove('details-open');
      }
      updateIngredientRowActions(row);
    }

    function setAllergenSelections(select, values = []) {
      if (!select) return;
      const valSet = new Set(values);
      Array.from(select.options).forEach(opt => {
        opt.selected = valSet.has(opt.value);
      });
    }

    function readAllergenSelections(select) {
      if (!select) return [];
      return Array.from(select.options)
        .filter(opt => opt.selected)
        .map(opt => opt.value);
    }

    function addIngredient(container, data = {}) {
      const compCardGuard = container ? container.closest('.component-card') : null;
      if (compCardGuard && compCardGuard.closest('.meal-card')?.dataset.mealFinished === '1') return null;
      const tmpl = document.getElementById('ingredient-template');
      const fragment = tmpl.content.cloneNode(true);
      const row = fragment.querySelector('.ingredient-row');
      row.dataset.id = data.id || randomId();
      const nameInput = row.querySelector('.ingredient-name');
      const qtyValueInput = row.querySelector('.ingredient-quantity-value');
      const qtyUnitSelect = row.querySelector('.ingredient-quantity-unit');
      const brandInput = row.querySelector('.ingredient-brand');
      const textarea = row.querySelector('textarea');
      const allergenSelect = row.querySelector('.ingredient-allergens');
      if (nameInput) nameInput.value = data.name || '';
      if (data.quantity) setQuantityFields(qtyValueInput, qtyUnitSelect, data.quantity);
      if (brandInput) brandInput.value = data.brandSource || data.brand || '';
      if (textarea) textarea.value = Array.isArray(data.subIngredients) ? data.subIngredients.join('\n') : data.subingredients || '';
      if (allergenSelect) setAllergenSelections(allergenSelect, data.allergens || []);
      const hasDetails = (brandInput && brandInput.value) || (textarea && textarea.value.trim());
      container.appendChild(fragment);
      setIngredientDetailsVisibility(row, !!hasDetails);
      updateIngredientRowActions(row);
      updateAddToComponentButton(container.closest('.component-card'));
      updateComponentTitle(container.closest('.component-card'));
      applySeasoningDefaults(row);
      autoSelectAllergensFromRow(row);
      const compCard = container.closest('.component-card');
      if (compCard) applyIngredientType(compCard, compCard.dataset.ingredientType || 'single');
      return row;
    }

    function addTimelineRow(tbody, data = {}) {
      const tmpl = document.getElementById('timeline-row-template');
      const fragment = tmpl.content.cloneNode(true);
      const tr = fragment.querySelector('tr');
      tr.dataset.id = data.id || randomId();
      const select = tr.querySelector('.timeline-symptom');
      populateTimelineSymptomSelect(select, data.symptomLabel || data.symptom || '');
      const timeInput = tr.querySelector('.timeline-time');
      const onsetInput = tr.querySelector('.timeline-onset');
      if (timeInput) timeInput.value = data.eventTime || currentTimeHHMM();
      tbody.appendChild(fragment);
      if (data.onsetMinutes != null && data.onsetMinutes !== '' && (!timeInput || !timeInput.value)) {
        if (onsetInput) onsetInput.value = data.onsetMinutes;
      } else {
        updateTimelineOnsetForRow(tr);
      }
      const card = tbody.closest('.meal-card');
      if (card) updateTimelineVisibility(card);
      return tr;
    }

    function createComponent(data = {}) {
      const tmpl = document.getElementById('component-template');
      const node = tmpl.content.cloneNode(true);
      const card = node.querySelector('.component-card');
      card.dataset.id = data.id || randomId();
      const nameInput = card.querySelector('.component-name-input');
      const qtyValueInput = card.querySelector('.component-quantity-value');
      const qtyUnitSelect = card.querySelector('.component-quantity-unit');
      const allergenSelect = card.querySelector('.component-allergens');
      const ingredientsContainer = card.querySelector('.ingredients-container');
      if (nameInput && data.name) nameInput.value = data.name;
      if (allergenSelect) setAllergenSelections(allergenSelect, data.allergens || []);
      if (data.quantity) setQuantityFields(qtyValueInput, qtyUnitSelect, data.quantity);
      const ingredients = data.ingredients && data.ingredients.length ? data.ingredients : [];
      if (ingredients.length === 0) {
        addIngredient(ingredientsContainer);
      } else {
        ingredients.forEach(ing => addIngredient(ingredientsContainer, ing));
      }
      applyIngredientType(card, data.ingredientType || 'single');
      if (nameInput && data.name) nameInput.value = data.name;
      return card;
    }

    function createMealCard(data = {}) {
      const tmpl = document.getElementById('meal-template');
      const fragment = tmpl.content.cloneNode(true);
      const card = fragment.querySelector('.meal-card');
      card.dataset.id = data.id || randomId();
      card.dataset.symptomFieldsHidden = '0';
      const typeSelect = card.querySelector('.meal-type-select');
      const timeInput = card.querySelector('.meal-time-input');
      const mealNameInput = card.querySelector('.meal-name-input');
      const portionValueInput = card.querySelector('.meal-portion-value');
      const portionUnitSelect = card.querySelector('.meal-portion-unit');
      const portionRow = card.querySelector('.portion-size-row');
      const portionToggleBtn = card.querySelector('.show-portion-btn');
      const symptomTimeInput = card.querySelector('.symptom-time-input');
      const symptomApproxInput = card.querySelector('.symptom-approx-checkbox');
      const componentsContainer = card.querySelector('.components-container');
      const timelineBody = card.querySelector('.timeline-body');
      const mealTitle = card.querySelector('.meal-title');
      const reheatedCheckbox = card.querySelector('.meal-reheated-option');
      const reheatedDaysInput = card.querySelector('.reheated-days-input');
      renderMealSymptomGrid(card);

      if (data.type && typeSelect) typeSelect.value = data.type;
      if (mealTitle && typeSelect) {
        mealTitle.textContent = typeSelect.value || 'Meal';
      }
      if (timeInput) timeInput.value = data.timeEaten || currentTimeHHMM();
      const timeApprox = card.querySelector('.meal-time-approx');
      if (timeApprox) timeApprox.checked = !!data.timeApprox;
      if (data.mealName && mealNameInput) mealNameInput.value = data.mealName;
      if (data.portionSize) {
        setQuantityFields(portionValueInput, portionUnitSelect, data.portionSize);
      }
      if (portionRow) {
        const hasPortion = !!(data.portionSize && String(data.portionSize).trim());
        portionRow.classList.toggle('hidden', !hasPortion);
        if (portionToggleBtn) portionToggleBtn.classList.toggle('hidden', hasPortion);
      }
      setMealNotes(card, data.notes);
      if (reheatedDaysInput) reheatedDaysInput.value = data.reheatedDays || '';
      if (reheatedCheckbox) reheatedCheckbox.checked = !!(data.notes && data.notes.includes('Reheated'));
      updateReheatedDaysVisibility(card);
      if (symptomTimeInput) symptomTimeInput.value = data.symptomTime || '';
      if (symptomApproxInput) symptomApproxInput.checked = !!data.symptomApprox;
      const components = data.components && data.components.length ? data.components : [];
      components.forEach(comp => {
        const compEl = createComponent(comp);
        componentsContainer.appendChild(compEl);
      });

      const symptoms = data.symptoms || {};
      const digestion = data.digestion || {};
      setSymptomValues(card, symptoms, digestion);

      const macros = data.macros || {};
      setMacroFields(card, macros);
      toggleMacroGrid(card, hasMacroValues(macros));

      const symptomChangeSelection = data.symptomChange || '';

      const timeline = data.timeline && data.timeline.length ? data.timeline : [];
      if (timeline.length > 0) {
        timeline.forEach(entry => addTimelineRow(timelineBody, entry));
      }

      const hasSymptomData = Object.values(symptoms || {}).some(v => (typeof v === 'boolean' ? v : (typeof v === 'string' ? v.trim() : Number(v) > 0))) ||
        Object.values(digestion || {}).some(v => (typeof v === 'boolean' ? v : (typeof v === 'string' ? v.trim() : Number(v) > 0))) ||
        (timeline && timeline.length > 0) || (data.symptomTime && data.symptomTime.trim()) || !!symptomChangeSelection;

      const shouldShowSymptoms = hasSymptomData || data.finished;
      const resolvedSymptomChange = symptomChangeSelection || (hasSymptomData ? 'yes' : 'no');

      setMealFinishedState(card, shouldShowSymptoms);
      setSymptomsUnlocked(card, shouldShowSymptoms);
      if (shouldShowSymptoms) {
        toggleSymptomChangeRow(card, true);
        applySymptomChangeSelection(card, resolvedSymptomChange, { applyBaseline: false });
      }
      updateFinishMealButtonLabel(card);

      updateAddIngredientButtonLabel(card);
      updateIngredientsVisibility(card);
      updateSymptomSectionVisibility(card);
      updateTimelineVisibility(card);
      updatePortionVisibility(card);

      return card;
    }

    function addMeal(data = {}) {
      const existingTypes = new Set();
      document.querySelectorAll('.meal-card .meal-type-select').forEach(sel => {
        if (sel.value && sel.value !== 'Snack' && sel.value !== 'Beverage') {
          existingTypes.add(sel.value);
        }
      });
      const fallbackType = MEAL_TYPES.find(t => (t === 'Snack' || t === 'Beverage') ? false : !existingTypes.has(t)) || 'Snack';
      const dataWithType = { ...data };
      if (!dataWithType.type) dataWithType.type = fallbackType;
      const container = document.getElementById('meals-container');
      const card = createMealCard(dataWithType);
      container.appendChild(card);
      updateMealTypeOptions();
      sortMealsByTime();
      return card;
    }

    function renumberMeals() {
      const cards = document.querySelectorAll('.meal-card');
      cards.forEach((card) => {
        const typeSelect = card.querySelector('.meal-type-select');
        const title = card.querySelector('.meal-title');
        const type = typeSelect ? typeSelect.value : 'Meal';
        if (title) title.textContent = type;
      });
    }

    function updateMealTypeOptions() {
      const cards = Array.from(document.querySelectorAll('.meal-card'));
      const usedTypes = new Set();
      cards.forEach(card => {
        const select = card.querySelector('.meal-type-select');
        const value = select ? select.value : null;
        if (value && value !== 'Snack' && value !== 'Beverage') {
          usedTypes.add(value);
        }
      });
      cards.forEach(card => {
        const select = card.querySelector('.meal-type-select');
        if (!select) return;
        const current = select.value;
        select.innerHTML = '';
        MEAL_TYPES.forEach(type => {
          if (type !== 'Snack' && type !== 'Beverage' && usedTypes.has(type) && current !== type) return;
          const opt = document.createElement('option');
          opt.value = type;
          opt.textContent = type;
          select.appendChild(opt);
        });
        if (Array.from(select.options).some(o => o.value === current)) {
          select.value = current;
        }
        updatePortionVisibility(card);
      });
    }

    function collectMeal(card, index) {
      const symptomDefaults = defaultSymptomState('symptoms');
      const digestionDefaults = defaultSymptomState('digestion');
      const meal = {
        id: card.dataset.id || randomId(),
        index: index + 1,
        type: (card.querySelector('.meal-type-select') || {}).value || 'Breakfast',
        timeEaten: (card.querySelector('.meal-time-input') || {}).value || null,
        timeApprox: !!(card.querySelector('.meal-time-approx') && card.querySelector('.meal-time-approx').checked),
        mealName: (card.querySelector('.meal-name-input') || {}).value || '',
        portionSize: collectQuantity(
          card.querySelector('.meal-portion-value'),
          card.querySelector('.meal-portion-unit')
        ),
        symptomTime: (card.querySelector('.symptom-time-input') || {}).value || '',
        symptomApprox: !!(card.querySelector('.symptom-approx-checkbox') && card.querySelector('.symptom-approx-checkbox').checked),
        notes: '',
        components: [],
        symptoms: { ...symptomDefaults },
        digestion: { ...digestionDefaults },
        timeline: [],
        reheatedDays: (card.querySelector('.reheated-days-input') || {}).value || '',
        symptomChange: (card.querySelector('.symptom-change-select') || {}).value || '',
        macros: collectMacros(card),
        finished: card.dataset.mealFinished === '1'
      };

      const noteSelections = getSelectedMealNotes(card);
      meal.notes = noteSelections.join(', ');

      const components = card.querySelectorAll('.component-card');
      components.forEach(comp => {
        const compData = {
          id: comp.dataset.id || randomId(),
          name: (comp.querySelector('.component-name-input') || {}).value || '',
          quantity: collectQuantity(
            comp.querySelector('.component-quantity-value'),
            comp.querySelector('.component-quantity-unit')
          ),
          allergens: readAllergenSelections(comp.querySelector('.component-allergens')),
          ingredientType: comp.dataset.ingredientType || 'single',
          ingredients: []
        };
        const ingRows = comp.querySelectorAll('.ingredient-row');
        ingRows.forEach(row => {
          const nameInput = row.querySelector('.ingredient-name');
          const brandInput = row.querySelector('.ingredient-brand');
          const qtyValueInput = row.querySelector('.ingredient-quantity-value');
          const qtyUnitSelect = row.querySelector('.ingredient-quantity-unit');
          const subText = row.querySelector('textarea');
          const allergenSelect = row.querySelector('.ingredient-allergens');
          const subParts = ((subText && subText.value) ? subText.value : '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          compData.ingredients.push({
            id: row.dataset.id || randomId(),
            name: nameInput ? nameInput.value : '',
            brandSource: brandInput ? brandInput.value : '',
            quantity: collectQuantity(qtyValueInput, qtyUnitSelect),
            subIngredients: subParts,
            allergens: readAllergenSelections(allergenSelect)
          });
        });
        meal.components.push(compData);
      });

      const symptomRanges = card.querySelectorAll('.symptom-range');
      symptomRanges.forEach(range => {
        const group = range.dataset.group;
        const scope = range.dataset.scope;
        const value = Number(range.value) || 0;
        if (scope === 'digestion') {
          meal.digestion[group] = value;
        } else {
          meal.symptoms[group] = value;
        }
      });

      card.querySelectorAll('.symptom-checkbox').forEach(box => {
        const group = box.dataset.group;
        const scope = box.dataset.scope;
        const cfg = symptomConfig.find(c => c.key === group);
        const target = scope === 'digestion' ? meal.digestion : meal.symptoms;
        target[group] = !!box.checked;
        if (cfg?.conditionalKey) {
          const conditional = card.querySelector(`.symptom-conditional[data-group="${group}"]`);
          target[cfg.conditionalKey] = conditional ? conditional.value : '';
        }
      });

      const timelineRows = card.querySelectorAll('.timeline-body tr');
      timelineRows.forEach(tr => {
        const symptomSelect = tr.querySelector('.timeline-symptom');
        const timeInput = tr.querySelector('.timeline-time');
        const onsetInput = tr.querySelector('.timeline-onset');
        meal.timeline.push({
          id: tr.dataset.id || randomId(),
          symptomLabel: symptomSelect ? symptomSelect.value : '',
          eventTime: timeInput ? timeInput.value : '',
          onsetMinutes: onsetInput && onsetInput.value !== '' ? Number(onsetInput.value) : 0
        });
      });

      if (meal.symptomChange === 'no') {
        Object.keys(meal.symptoms).forEach(key => { meal.symptoms[key] = null; });
        Object.keys(meal.digestion).forEach(key => { meal.digestion[key] = null; });
        meal.symptomTime = '';
        meal.symptomApprox = false;
      }

      return meal;
    }

    function collectEntryFromUI(existing) {
      const cards = Array.from(document.querySelectorAll('.meal-card'));
      const meals = cards.map((card, idx) => collectMeal(card, idx));
      const dateDisplay = document.getElementById('date-display');
      const datePicker = document.getElementById('date-picker');
      const baselineTimeField = document.getElementById('baseline-time');
      const baselineApproxField = document.getElementById('baseline-approx');
      const baselineCard = document.querySelector('.premeal-card');
      const displayDate = dateDisplay ? dateDisplay.value : formatDisplayDate(new Date());
      const pickerValue = datePicker ? datePicker.value : '';
      const parsedIso = pickerValue || displayToIso(displayDate);
      const isoDate = parsedIso || (existing && existing.isoDate) || todayIso();
      const now = new Date().toISOString();
      const preMealLocked = baselineCard ? baselineCard.classList.contains('premeal-locked') : false;
      return {
        id: (existing && existing.id) || isoDate,
        isoDate,
        displayDate: displayDate || (existing && existing.displayDate) || formatDisplayDate(isoDate),
        notesForToday: (existing && existing.notesForToday) || '',
        preMealState: collectPreMealState(),
        preMealTime: baselineTimeField && baselineTimeField.value ? baselineTimeField.value : (existing && existing.preMealTime) || currentTimeHHMM(),
        preMealApprox: baselineApproxField ? !!baselineApproxField.checked : (existing && existing.preMealApprox) || false,
        preMealLocked,
        meals,
        createdAt: (existing && existing.createdAt) || now,
        updatedAt: now
      };
    }

    function renderEntry(entry) {
      renderBaselineSymptomGrid();
      const dateDisplay = document.getElementById('date-display');
      const datePicker = document.getElementById('date-picker');
      if (datePicker) datePicker.value = entry.isoDate || '';
      updateDateDisplay(entry.isoDate);
      const baselineTimeField = document.getElementById('baseline-time');
      if (baselineTimeField) baselineTimeField.value = entry.preMealTime || currentTimeHHMM();
      const baselineApproxField = document.getElementById('baseline-approx');
      if (baselineApproxField) baselineApproxField.checked = !!entry.preMealApprox;
      setBaselineLocked(!!entry.preMealLocked);
      populatePreMealState(entry.preMealState);

      const container = document.getElementById('meals-container');
      container.innerHTML = '';
      if (entry.meals && entry.meals.length) {
        entry.meals
          .sort(function (a, b) { return (a.index || 0) - (b.index || 0); })
          .forEach(function (meal) { addMeal(meal); });
      }
      refreshRangeDisplays();
      document.querySelectorAll('.meal-card').forEach(card => updateAllTimelineOnsets(card));
      sortMealsByTime();
      updateMealTypeOptions();
      updateNewEntryButtonVisibility();
      updateSecondaryAddMealVisibility();
      updateBaselineDependentControls();
    }

    function renderEntrySelector(log, currentId) {
      const select = document.getElementById('entry-select');
      select.innerHTML = '';
      const entries = [...log.entries].sort((a, b) => (a.isoDate < b.isoDate ? 1 : -1));
      if (entries.length === 0) {
        const opt = document.createElement('option');
        opt.textContent = 'No saved entries yet';
        opt.disabled = true;
        opt.selected = true;
        select.appendChild(opt);
        return;
      }
      entries.forEach(entry => {
        const opt = document.createElement('option');
        opt.value = entry.id;
        const label = entry.displayDate || formatDisplayDate(entry.isoDate) || entry.isoDate;
        opt.textContent = `${label}`;
        if (entry.id === currentId) opt.selected = true;
        select.appendChild(opt);
      });
    }

    function upsertEntry(log, entry) {
      const existingIdx = log.entries.findIndex(e => e.isoDate === entry.isoDate);
      if (existingIdx >= 0) {
        log.entries[existingIdx] = { ...log.entries[existingIdx], ...entry };
      } else {
        log.entries.push(entry);
      }
    }

    function ensureEntryForDate(log, isoDate) {
      let entry = log.entries.find(e => e.isoDate === isoDate);
      if (!entry) {
        entry = createEmptyEntry(isoDate);
        log.entries.push(entry);
        saveLog(log);
      }
      return entry;
    }

    function updateDateDisplay(isoDate) {
      const dateDisplay = document.getElementById('date-display');
      if (dateDisplay) {
        dateDisplay.value = isoDate ? formatDisplayDate(isoDate) : '';
      }
    }

    function isBaselineLocked() {
      const card = document.querySelector('.premeal-card');
      return !!(card && card.classList.contains('premeal-locked'));
    }

    function updateBaselineDependentControls() {
      const locked = isBaselineLocked();
      const addButtons = [document.getElementById('add-meal-btn'), document.getElementById('add-meal-btn-secondary')];
      addButtons.forEach(btn => {
        if (btn) btn.disabled = !locked;
      });
      const saveBtn = document.getElementById('save-draft-btn');
      if (saveBtn) saveBtn.disabled = !locked;
      updateSecondaryAddMealVisibility();
    }

    function updateSecondaryAddMealVisibility() {
      const container = document.getElementById('secondary-add-meal');
      const btn = document.getElementById('add-meal-btn-secondary');
      if (!container || !btn) return;
      const hasFinished = document.querySelector('.meal-card[data-meal-finished="1"]');
      container.classList.toggle('hidden', !hasFinished);
      btn.disabled = !isBaselineLocked();
    }

    function updateNewEntryButtonVisibility() {
      const btn = document.getElementById('new-entry-btn');
      if (!btn) return;
      const today = todayIso();
      const currentEntry = currentLog.entries.find(e => e.id === currentEntryId);
      const hasTodayDraft = currentLog.entries.some(e => e.isoDate === today);
      const hide = (currentEntry && currentEntry.isoDate === today) || hasTodayDraft;
      btn.classList.toggle('hidden', hide);
      btn.disabled = !companionAvailable;
      if (!companionAvailable) {
        btn.title = 'Connect or import a companion file to start a new entry';
      } else {
        btn.removeAttribute('title');
      }
    }

    async function saveDraft() {
      try {
        const saveBtn = document.getElementById('save-draft-btn');
        if (saveBtn && saveBtn.disabled) {
          alert('Finish baseline before saving.');
          return;
        }
        const existing = currentLog.entries.find(e => e.id === currentEntryId);
        const entry = collectEntryFromUI(existing);
        upsertEntry(currentLog, entry);
        currentEntryId = entry.id;
        saveLog(currentLog);
        renderEntrySelector(currentLog, currentEntryId);
        updateNewEntryButtonVisibility();
        await saveLogToFileIfConnected();
        alert('Entry saved.');
      } catch (err) {
        console.error(err);
        alert('Unable to save entry (storage error).');
      }
    }

    function exportLog() {
      try {
        const log = currentLog && currentLog.entries ? currentLog : loadLog();
        const payload = JSON.stringify(log, null, 2);
        const blob = new Blob([payload], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const stamp = new Date().toISOString().slice(0, 10);
        link.href = url;
        link.download = `food-journal-log-${stamp}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        alert('Unable to export data.');
      }
    }

    async function deleteDraft() {
      const currentEntry = currentLog.entries.find(e => e.id === currentEntryId);
      if (!currentEntry) {
        alert('No entry selected to delete.');
        return;
      }
      const filtered = currentLog.entries.filter(entry => entry.id !== currentEntryId);
      currentLog.entries = filtered;
      if (currentLog.entries.length === 0) {
        const fresh = createEmptyEntry(todayIso());
        currentLog.entries.push(fresh);
        currentEntryId = fresh.id;
      } else {
        const sorted = [...currentLog.entries].sort((a, b) => (a.isoDate < b.isoDate ? 1 : -1));
        currentEntryId = sorted[0].id;
      }
      saveLog(currentLog);
      const nextEntry = currentLog.entries.find(e => e.id === currentEntryId) || currentLog.entries[0];
      renderEntrySelector(currentLog, currentEntryId);
      renderEntry(nextEntry);
      await saveLogToFileIfConnected();
      alert('Current entry deleted.');
    }

    function updateReheatedDaysVisibility(card) {
      if (!card) return;
      const checkbox = card.querySelector('.meal-reheated-option');
      const row = card.querySelector('.reheated-days-row');
      const show = checkbox && checkbox.checked;
      if (row) row.classList.toggle('hidden', !show);
    }

    function updateDataFileStatus(message) {
      const status = document.getElementById('data-file-status');
      if (!status) return;
      status.textContent = message;
    }

    function setCreateDataFileVisible(show) {
      const btn = document.getElementById('create-data-file-btn');
      if (!btn) return;
      btn.classList.toggle('hidden', !show);
    }

    function setConnectDataFileVisible(show) {
      const btn = document.getElementById('connect-data-file-btn');
      if (!btn) return;
      btn.classList.toggle('hidden', !show);
    }

    function setImportDataFileVisible(show) {
      const btn = document.getElementById('import-data-file-btn');
      if (!btn) return;
      btn.classList.toggle('hidden', !show);
    }

    function setCompanionAvailable(flag) {
      companionAvailable = !!flag;
      updateNewEntryButtonVisibility();
      if (companionAvailable) {
        setCreateDataFileVisible(false);
        setConnectDataFileVisible(false);
        setImportDataFileVisible(false);
      }
    }

    function setCreateButtonLabel(label) {
      const btn = document.getElementById('create-data-file-btn');
      if (!btn) return;
      btn.textContent = label;
    }

    function downloadCompanionTemplate(log = null) {
      const payloadLog = log && Array.isArray(log.entries) && log.entries.length ? log : { version: 1, entries: [createEmptyEntry(todayIso())] };
      const blob = new Blob([JSON.stringify(payloadLog, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = EXPECTED_DATA_FILE_NAME;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    async function applyDataFileHandle(handle, statusLabel = 'Connected to') {
      if (!handle) return false;
      const permitted = await verifyHandlePermission(handle, 'readwrite');
      if (!permitted) {
        updateDataFileStatus('Permission to access the companion file is required.');
        return false;
      }
      dataFileHandle = handle;
      await storeDataFileHandle(handle);
      const fileLog = await safeReadLogFromHandle(handle);
      currentLog = fileLog;
      const todays = currentLog.entries.find(e => e.isoDate === todayIso());
      currentEntryId = todays ? todays.id : (currentLog.entries[0]?.id || todayIso());
      saveLog(currentLog);
      renderEntrySelector(currentLog, currentEntryId);
      const entryToRender = currentLog.entries.find(e => e.id === currentEntryId) || currentLog.entries[0];
      if (entryToRender) renderEntry(entryToRender);
      updateDataFileStatus(`${statusLabel} ${handle.name}`);
      setCreateDataFileVisible(false);
      setConnectDataFileVisible(false);
      setImportDataFileVisible(false);
      setCompanionAvailable(true);
      return true;
    }

    async function tryAutoConnectSavedFile() {
      if (!supportsFileAccess()) return;
      try {
        const savedHandle = await loadSavedDataFileHandle();
        if (!savedHandle) {
          updateDataFileStatus('No companion data file found.');
          setCreateDataFileVisible(true);
          setCompanionAvailable(false);
          return;
        }
        await applyDataFileHandle(savedHandle, 'Connected to');
      } catch (err) {
        console.warn('Auto-connect to saved companion file failed', err);
        await clearSavedDataFileHandle();
        updateDataFileStatus('No companion data file found.');
        setCreateDataFileVisible(true);
        setCompanionAvailable(false);
      }
    }

    async function saveLogToFileIfConnected() {
      if (!dataFileHandle) return;
      try {
        const permitted = await verifyHandlePermission(dataFileHandle, 'readwrite');
        if (!permitted) {
          updateDataFileStatus('Permission to save to the companion file was denied.');
          return;
        }
        await writeLogToFile(dataFileHandle, currentLog);
        updateDataFileStatus(`Saved to ${dataFileHandle.name}`);
      } catch (err) {
        console.error('Unable to save to file', err);
        updateDataFileStatus('Unable to save to companion file (permission or connection issue).');
      }
    }

    function isExpectedDataFileName(handle) {
      return !!handle && handle.name === EXPECTED_DATA_FILE_NAME;
    }

    async function connectDataFile() {
      if (!supportsFileAccess()) {
        alert('Your browser does not support choosing a companion data file. Use the import/download controls below.');
        return;
      }
      try {
        let handle = await loadSavedDataFileHandle();
        if (handle && !(await verifyHandlePermission(handle, 'readwrite'))) {
          handle = null;
        }
        if (!handle) {
          handle = await promptForExistingDataFile();
        }
        if (handle && !isExpectedDataFileName(handle)) {
          alert(`Please select the companion file named "${EXPECTED_DATA_FILE_NAME}".`);
          updateDataFileStatus('No companion data file found.');
          setCreateDataFileVisible(true);
          return;
        }
        if (!handle) {
          updateDataFileStatus('No companion data file found.');
          setCreateDataFileVisible(true);
          return;
        }
        await applyDataFileHandle(handle, handle.name ? 'Connected to' : 'Connected');
      } catch (err) {
        if (err?.name === 'AbortError') return;
        console.error(err);
        alert('Unable to open data file.');
      }
    }

    async function createAndConnectDataFile() {
      if (!supportsFileAccess()) {
        downloadCompanionTemplate(currentLog);
        updateDataFileStatus(`Downloaded ${EXPECTED_DATA_FILE_NAME}. Place it with index.html (or your cloud folder) and import it to continue.`);
        setImportDataFileVisible(true);
        setCompanionAvailable(false);
        return;
      }
      try {
        const handle = await promptToCreateDataFile();
        if (!handle) {
          updateDataFileStatus('No companion data file found.');
          setCreateDataFileVisible(true);
          return;
        }
        if (!isExpectedDataFileName(handle)) {
          updateDataFileStatus(`Please create the file as "${EXPECTED_DATA_FILE_NAME}".`);
          setCreateDataFileVisible(true);
          return;
        }
        await applyDataFileHandle(handle, 'Connected to');
      } catch (err) {
        if (err?.name === 'AbortError') return;
        console.error('Unable to create companion file', err);
        updateDataFileStatus('Unable to create companion data file.');
        setCreateDataFileVisible(true);
      }
    }

    async function importCompanionFile(file) {
      if (!file) return;
      try {
        const text = await file.text();
        const parsed = JSON.parse(text);
        const log = normalizeLogObject(parsed);
        if (!log.entries.length) {
          log.entries.push(createEmptyEntry(todayIso()));
        }
        currentLog = log;
        saveLog(currentLog);
        const todays = currentLog.entries.find(e => e.isoDate === todayIso());
        currentEntryId = todays ? todays.id : currentLog.entries[0].id;
        renderEntrySelector(currentLog, currentEntryId);
        renderEntry(currentLog.entries.find(e => e.id === currentEntryId));
        updateNewEntryButtonVisibility();
        const expectedNote = file.name === EXPECTED_DATA_FILE_NAME ? '' : ` (expected ${EXPECTED_DATA_FILE_NAME})`;
        updateDataFileStatus(`Loaded ${file.name}${expectedNote}. Updates will stay in this browser unless you reconnect the companion file.`);
        setCreateDataFileVisible(false);
        setImportDataFileVisible(false);
        setConnectDataFileVisible(false);
        setCompanionAvailable(true);
      } catch (err) {
        console.error('Manual import failed', err);
        updateDataFileStatus('Unable to import companion file. Please ensure it is valid JSON.');
        alert('Unable to import companion file. Please ensure it is valid JSON.');
        setCompanionAvailable(false);
      }
    }

    let currentLog = loadLog();
    let currentEntryId = null;
    let dataFileHandle = null;
    let companionAvailable = false;

    document.addEventListener('click', event => {
      const target = event.target;
      if (target.classList.contains('add-component-btn')) {
        const mealCard = target.closest('.meal-card');
        if (mealCard && mealCard.dataset.mealFinished === '1') return;
        const container = mealCard ? mealCard.querySelector('.components-container') : null;
        if (container) {
          const comp = createComponent({});
          container.appendChild(comp);
          updateSymptomSectionVisibility(mealCard);
          updateIngredientsVisibility(mealCard);
        }
      }

      if (target.classList.contains('finish-baseline-btn')) {
        setBaselineLocked(true);
      }

      if (target.classList.contains('show-portion-btn')) {
        const mealCard = target.closest('.meal-card');
        const portionRow = mealCard ? mealCard.querySelector('.portion-size-row') : null;
        if (portionRow) portionRow.classList.remove('hidden');
        target.classList.add('hidden');
      }

      if (target.classList.contains('remove-component-btn')) {
        const comp = target.closest('.component-card');
        if (comp) comp.remove();
      }

      if (target.classList.contains('add-ingredient-btn')) {
        const comp = target.closest('.component-card');
        const container = comp ? comp.querySelector('.ingredients-container') : null;
        if (container) {
          addIngredient(container);
          const mealCard = target.closest('.meal-card');
          updateSymptomSectionVisibility(mealCard);
        }
      }

      if (target.classList.contains('toggle-component-btn')) {
        const comp = target.closest('.component-card');
        if (comp) {
          promoteIngredientToComponent(comp);
          setComponentMode(comp, true);
          updateAddToComponentButton(comp);
          updateComponentTitle(comp);
        }
      }

      if (target.classList.contains('demote-component-btn')) {
        const comp = target.closest('.component-card');
        if (comp) {
          setComponentMode(comp, false);
          updateComponentToggleButton(comp);
          updateAddToComponentButton(comp);
          updateComponentTitle(comp);
        }
      }

      if (target.classList.contains('remove-ingredient-btn')) {
        const row = target.closest('.ingredient-row');
        if (row) {
          const compCard = row.closest('.component-card');
          row.remove();
          updateComponentToggleButton(compCard);
          updateComponentTitle(compCard);
          const mealCard = compCard ? compCard.closest('.meal-card') : null;
          updateSymptomSectionVisibility(mealCard);
        }
      }

      if (target.classList.contains('add-timeline-row-btn')) {
        const card = target.closest('.meal-card');
        const body = card ? card.querySelector('.timeline-body') : null;
        if (body) addTimelineRow(body, {});
      }

      if (target.classList.contains('remove-timeline-row-btn')) {
        const tr = target.closest('tr');
        if (tr) {
          const card = tr.closest('.meal-card');
          tr.remove();
          updateTimelineVisibility(card);
        }
      }

      if (target.classList.contains('finish-meal-btn')) {
        const card = target.closest('.meal-card');
        if (card) {
          setMealFinishedState(card, true);
          setSymptomsUnlocked(card, true);
          toggleSymptomChangeRow(card, true);
          applySymptomChangeSelection(card, 'no', { applyBaseline: false });
          updateSymptomSectionVisibility(card);
        }
      }

      if (target.classList.contains('remove-meal-btn')) {
        const meal = target.closest('.meal-card');
        if (meal) meal.remove();
        renumberMeals();
        updateMealTypeOptions();
        updateSecondaryAddMealVisibility();
      }

      if (target.closest('.meal-note-option')) {
        const mealCard = target.closest('.meal-card');
        updateIngredientsVisibility(mealCard);
        updateReheatedDaysVisibility(mealCard);
      }
      const mealPrepLabel = target.closest('label');
      if (mealPrepLabel) {
        const prepInput = mealPrepLabel.querySelector('.meal-note-option');
        if (prepInput) {
          const mealCard = mealPrepLabel.closest('.meal-card');
          setTimeout(() => {
            updateIngredientsVisibility(mealCard);
            updateReheatedDaysVisibility(mealCard);
          }, 0);
        }
      }
    });

    document.addEventListener('input', event => {
      if (event.target.classList.contains('range-input')) {
        setRangeValue(event.target, Number(event.target.value) || 0);
        const card = event.target.closest('.meal-card');
        if (card) updateTimelineVisibility(card);
      }
      if (event.target.classList.contains('symptom-checkbox')) {
        const conditional = event.target.closest('.symptom-field')?.querySelector('.symptom-conditional');
        if (conditional) conditional.parentElement?.classList.toggle('hidden', !event.target.checked);
      }
      if (event.target.classList.contains('timeline-time')) {
        const row = event.target.closest('tr');
        updateTimelineOnsetForRow(row);
      }
      if (event.target.classList.contains('component-name-input') || event.target.classList.contains('ingredient-name')) {
        const card = event.target.closest('.component-card');
        updateComponentTitle(card);
        updateComponentToggleButton(card);
        updateAddToComponentButton(card);
        if (event.target.classList.contains('ingredient-name')) {
          const row = event.target.closest('.ingredient-row');
          updateIngredientRowActions(row);
        }
        const mealCard = event.target.closest('.meal-card');
        updateSymptomSectionVisibility(mealCard);
        updateIngredientsVisibility(mealCard);
      }
      if (event.target.classList.contains('meal-name-input')) {
        const mealCard = event.target.closest('.meal-card');
        updateIngredientsVisibility(mealCard);
        updateAddIngredientButtonLabel(mealCard);
        updateFinishMealButtonLabel(mealCard);
      }
      if (event.target.classList.contains('meal-note-option')) {
        const mealCard = event.target.closest('.meal-card');
        updateIngredientsVisibility(mealCard);
        updateReheatedDaysVisibility(mealCard);
      }
      if (event.target.closest('.subingredients') && event.target.tagName === 'TEXTAREA') {
        const row = event.target.closest('.ingredient-row');
        autoSelectAllergensFromRow(row);
      }
    });

    document.addEventListener('change', event => {
      if (event.target.classList.contains('meal-type-select')) {
        updateMealTypeOptions();
        renumberMeals();
        const card = event.target.closest('.meal-card');
        updatePortionVisibility(card);
      }
      if (event.target.classList.contains('ingredient-type-select')) {
        const compCard = event.target.closest('.component-card');
        applyIngredientType(compCard, event.target.value);
      }
      if (event.target.classList.contains('meal-time-input')) {
        const card = event.target.closest('.meal-card');
        updateAllTimelineOnsets(card);
        sortMealsByTime();
      }
      if (event.target.classList.contains('meal-note-option')) {
        const card = event.target.closest('.meal-card');
        updateIngredientsVisibility(card);
        updateReheatedDaysVisibility(card);
      }
      if (event.target.classList.contains('symptom-change-select')) {
        const card = event.target.closest('.meal-card');
        applySymptomChangeSelection(card, event.target.value, { applyBaseline: true });
        updateTimelineVisibility(card);
      }
      if (event.target.id === 'entry-select') {
        const selectedId = event.target.value;
        const found = currentLog.entries.find(e => e.id === selectedId);
        if (found) {
          currentEntryId = found.id;
          renderEntrySelector(currentLog, currentEntryId);
          renderEntry(found);
          renumberMeals();
        }
      }
    });

  document.getElementById('add-meal-btn').addEventListener('click', () => {
    if (!isBaselineLocked()) return;
    addMeal();
  });
  document.getElementById('add-meal-btn-secondary').addEventListener('click', () => {
    if (!isBaselineLocked()) return;
    addMeal();
  });
  document.getElementById('connect-data-file-btn').addEventListener('click', () => connectDataFile());
  document.getElementById('create-data-file-btn').addEventListener('click', () => createAndConnectDataFile());
  document.getElementById('import-data-file-btn').addEventListener('click', () => {
    const input = document.getElementById('import-data-file-input');
    if (input) input.click();
  });
  document.getElementById('import-data-file-input').addEventListener('change', async (event) => {
    const file = event.target.files && event.target.files[0];
    if (file) await importCompanionFile(file);
    event.target.value = '';
  });
  document.getElementById('new-entry-btn').addEventListener('click', () => {
    const btn = document.getElementById('new-entry-btn');
    if (btn && btn.disabled) return;
    const iso = todayIso();
    let entry = currentLog.entries.find(e => e.isoDate === iso);
    if (!entry) {
      entry = createEmptyEntry(iso);
        currentLog.entries.push(entry);
        saveLog(currentLog);
        saveLogToFileIfConnected();
      }
      currentEntryId = entry.id;
      renderEntrySelector(currentLog, currentEntryId);
      renderEntry(entry);
      renumberMeals();
      updateNewEntryButtonVisibility();
    });

    async function initApp() {
      await loadSymptomConfig();
      renderBaselineSymptomGrid();
      const dateDisplay = document.getElementById('date-display');
      const datePicker = document.getElementById('date-picker');
      if (dateDisplay && datePicker) {
        dateDisplay.addEventListener('click', () => {
          if (typeof datePicker.showPicker === 'function') {
            datePicker.showPicker();
          } else {
            datePicker.focus();
            datePicker.click();
          }
        });
        dateDisplay.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            if (typeof datePicker.showPicker === 'function') {
              datePicker.showPicker();
            } else {
              datePicker.focus();
              datePicker.click();
            }
          }
        });
        datePicker.addEventListener('change', () => {
          if (!datePicker.value) return;
          updateDateDisplay(datePicker.value);
          const existing = currentLog.entries.find(entry => entry.isoDate === datePicker.value);
          if (existing) {
            currentEntryId = existing.id;
            renderEntrySelector(currentLog, currentEntryId);
            renderEntry(existing);
          } else {
            const fresh = createEmptyEntry(datePicker.value);
            currentLog.entries.push(fresh);
            saveLog(currentLog);
            currentEntryId = fresh.id;
            renderEntrySelector(currentLog, currentEntryId);
            renderEntry(fresh);
          }
          renumberMeals();
          updateNewEntryButtonVisibility();
        });
      }
      const hasNativeFileAccess = supportsFileAccess();
      if (!hasNativeFileAccess) {
        updateDataFileStatus(`No companion data file found. In Safari, use Import to open ${EXPECTED_DATA_FILE_NAME} or Download to create one.`);
        setConnectDataFileVisible(false);
        setImportDataFileVisible(true);
        setCreateDataFileVisible(true);
        setCreateButtonLabel('Download companion file');
      } else {
        setCreateButtonLabel('Create companion file');
        setImportDataFileVisible(false);
        setCreateDataFileVisible(false);
        setConnectDataFileVisible(true);
        await tryAutoConnectSavedFile();
      }
      let activeEntry = ensureEntryForDate(currentLog, todayIso());
      currentEntryId = activeEntry.id;
      renderEntrySelector(currentLog, currentEntryId);
      renderEntry(activeEntry);
      renumberMeals();
      refreshRangeDisplays();
      updateNewEntryButtonVisibility();
    }

    function setSymptomsUnlocked(card, unlocked) {
      if (!card) return;
      card.dataset.symptomsUnlocked = unlocked ? '1' : '0';
      const symptomTimeInput = card.querySelector('.symptom-time-input');
      if (unlocked && symptomTimeInput && !symptomTimeInput.value) {
        symptomTimeInput.value = currentTimeHHMM();
      }
      updateSymptomSectionVisibility(card);
      updateTimelineVisibility(card);
    }

    // Run init when the DOM is ready, even if this script runs after DOMContentLoaded
      if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initApp().catch(err => {
          console.error('Initialization failed; rendering fallback entry.', err);
          const fallback = ensureEntryForDate(currentLog, todayIso());
          currentEntryId = fallback.id;
          renderEntrySelector(currentLog, currentEntryId);
          renderEntry(fallback);
          renumberMeals();
          refreshRangeDisplays();
          updateNewEntryButtonVisibility();
          updateDataFileStatus('Loaded local draft (companion file unavailable).');
        });
      });
    } else {
      initApp().catch(err => {
        console.error('Initialization failed; rendering fallback entry.', err);
        const fallback = ensureEntryForDate(currentLog, todayIso());
        currentEntryId = fallback.id;
        renderEntrySelector(currentLog, currentEntryId);
        renderEntry(fallback);
        renumberMeals();
        refreshRangeDisplays();
        updateNewEntryButtonVisibility();
        updateDataFileStatus('Loaded local draft (companion file unavailable).');
      });
    }
  </script>
</body>
</html>
